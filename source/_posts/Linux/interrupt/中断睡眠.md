---
title: 中断不能睡眠
date: 2018-05-14 10:25:00
categories:
- Linux
- power
---

执行在中断上下文的代码：
a)中断的 top half (interrupt handler)
b)bottom half(softirq,tasklet等)

看了一些文章和讨论，如下：
> 对于Linux 调度器，它的目标就是调度一个线程，一个线程就是调度实体。中断上下文没有专属的task struct，内核无从调度，中断上下文（hard irq和softirq context）并不参与调度，它们是异步事件的处理机制，目标就是尽快完成处理，返回现场。
<!--more-->
但也有说：
> 其中一个比较流行的答案就是：中断没有进程上下文，如果睡眠之后，进程调度子系统没法来唤醒它。仔细想想，这个答案其实不然。在X86的实现上，中断发生时会借用当前被中断进程的Kernel stack，所以实际上中断是借宿在这个进程上，这个时候中断睡眠是完全可以（当然不合理）的。中断上下文会保存在这个进程的stack上，等到这个进程被唤醒时，会从中断ISR中继续执行。所以，这不是此问题的根本原因。

但这个解释有个问题就是进程什么时候被唤醒，因为：
> 如果中断睡眠，对被中断的进程不公。发生中断时，中断借用当前被中断的进程的Stack，但是此中断和此线程是毫无关系的。如果此时中断去睡眠，那么此被中断的进程不得不等待中断被继续调度执行。这样，此进程需要等待与他毫无关系的资源不确定的时间，这样设计系统不合理。

其实实际上来讲，中断中睡眠技术上可能能做到，但是要考虑的东西太多而且意义不大，因为：
**中断服务程序应该尽快处理完中断，保证IO吞吐率以及响应的实时性，在中断程序中睡眠原本就违背中断程序本身的意义所在。**
